import { useEffect, useState } from 'react'
import './App.css'
import logoImg from './assets/logo/framefolio_logo.png'
import iconWhite from './assets/icons/framefolio_icon_white.png'
import iconBlack from './assets/icons/framefolio_icon_black.png'

const API_URL = `${window.location.origin}/api`

// ===== UPLOAD MODALS =====

function UploadProgressModal({ jobId, onComplete, onError }) {
  const [status, setStatus] = useState(null)
  const [error, setError] = useState(null)

  useEffect(() => {
    if (!jobId) return

    const pollInterval = setInterval(async () => {
      try {
        const response = await fetch(`${API_URL}/images/upload/${jobId}/status`)
        const data = await response.json()
        setStatus(data)

        if (data.status === 'error') {
          setError(data.errors?.[0] || 'Upload failed')
          clearInterval(pollInterval)
          onError(data.errors)
        } else if (data.status === 'complete') {
          clearInterval(pollInterval)
          onComplete(data)
        }
      } catch (err) {
        setError(err.message)
        clearInterval(pollInterval)
      }
    }, 300)

    return () => clearInterval(pollInterval)
  }, [jobId, onComplete, onError])

  if (!status) return null

  return (
    <div className="modal-overlay">
      <div className="modal" onClick={(e) => e.stopPropagation()}>
        <div className="modal-header">
          <h2>Uploading...</h2>
        </div>

        <div className="modal-content">
          {error ? (
            <div style={{ color: 'var(--error-color)', padding: '10px' }}>
              <strong>Error:</strong> {error}
            </div>
          ) : (
            <>
              <div className="progress-bar-container">
                <div
                  className="progress-bar-fill"
                  style={{ width: `${status.progress}%` }}
                />
              </div>
              <p style={{ textAlign: 'center', marginTop: '10px' }}>
                {status.progress}% ({status.results?.length || 0} of {status.total_files})
              </p>
              <p style={{ color: 'var(--text-muted)', textAlign: 'center', fontSize: '14px' }}>
                {status.current_step}
              </p>
            </>
          )}
        </div>
      </div>
    </div>
  )
}

function DuplicateModal({ result, jobId, onAction }) {
  const [selectedAction, setSelectedAction] = useState(null)

  async function handleAction(action) {
    setSelectedAction(action)
    try {
      const response = await fetch(
        `${API_URL}/images/upload/${jobId}/duplicate-action`,
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            filename: result.filename,
            action: action
          })
        }
      )
      const data = await response.json()
      if (!data.error) {
        onAction(action)
      }
    } catch (err) {
      console.error('Duplicate action failed:', err)
    }
  }

  return (
    <div className="modal-overlay" onClick={() => onAction('skip')}>
      <div className="modal duplicate-modal" onClick={(e) => e.stopPropagation()}>
        <div className="modal-header">
          <h2>File Already Exists</h2>
        </div>

        <div className="modal-content">
          <p>
            <strong>{result.filename}</strong> appears to be a duplicate.
          </p>

          <div className="duplicate-comparison">
            <div className="comparison-column">
              <h4>Existing File</h4>
              {result.duplicate.thumbnail && (
                <img
                  src={result.duplicate.thumbnail}
                  alt="Existing"
                  style={{ maxWidth: '100%', borderRadius: '4px', marginBottom: '10px' }}
                />
              )}
              <div className="file-details">
                <p><strong>Name:</strong> {result.duplicate.info.name}</p>
                <p><strong>Size:</strong> {result.duplicate.info.size_mb} MB</p>
                <p>
                  <strong>Dimensions:</strong> {result.duplicate.info.width}√ó
                  {result.duplicate.info.height}
                </p>
              </div>
            </div>

            <div className="comparison-column">
              <h4>Incoming File</h4>
              {result.incoming.thumbnail && (
                <img
                  src={result.incoming.thumbnail}
                  alt="Incoming"
                  style={{ maxWidth: '100%', borderRadius: '4px', marginBottom: '10px' }}
                />
              )}
              <div className="file-details">
                <p><strong>Name:</strong> {result.incoming.info.name}</p>
                <p><strong>Size:</strong> {result.incoming.info.size_mb} MB</p>
                <p>
                  <strong>Dimensions:</strong> {result.incoming.info.width}√ó
                  {result.incoming.info.height}
                </p>
              </div>
            </div>
          </div>
        </div>

        <div className="modal-footer duplicate-actions">
          <button
            className="btn-secondary"
            onClick={() => handleAction('skip')}
            disabled={selectedAction}
          >
            Skip This File
          </button>
          <button
            className="btn-warning"
            onClick={() => handleAction('overwrite')}
            disabled={selectedAction}
          >
            Overwrite Existing
          </button>
          <button
            className="btn-primary"
            onClick={() => handleAction('import_anyway')}
            disabled={selectedAction}
          >
            Import as New
          </button>
        </div>
      </div>
    </div>
  )
}

function CropPositioningModal({ result, jobId, onComplete }) {
  const [cropBox, setCropBox] = useState({
    x: 0.1,
    y: 0.1,
    width: 0.8,
    height: 0.8
  })
  const [isDragging, setIsDragging] = useState(false)
  const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 })
  const [isSubmitting, setIsSubmitting] = useState(false)

  const containerRef = React.useRef(null)
  const aspectInfo = result.aspect_info

  const displayAspect = aspectInfo.width / aspectInfo.height
  const targetAspect = 3840 / 2160
  const maxWidth = 400
  const maxHeight = 400
  let previewWidth, previewHeight

  if (displayAspect > maxWidth / maxHeight) {
    previewWidth = maxWidth
    previewHeight = maxWidth / displayAspect
  } else {
    previewHeight = maxHeight
    previewWidth = maxHeight * displayAspect
  }

  function handleMouseDown(e) {
    if (!containerRef.current) return
    setIsDragging(true)
    const rect = containerRef.current.getBoundingClientRect()
    setDragOffset({
      x: e.clientX - rect.left,
      y: e.clientY - rect.top
    })
  }

  function handleMouseMove(e) {
    if (!isDragging || !containerRef.current) return

    const rect = containerRef.current.getBoundingClientRect()
    const currentX = e.clientX - rect.left
    const currentY = e.clientY - rect.top

    const deltaX = (currentX - dragOffset.x) / previewWidth
    const deltaY = (currentY - dragOffset.y) / previewHeight

    setCropBox(prev => {
      let newBox = {
        ...prev,
        x: Math.max(0, Math.min(1 - prev.width, prev.x + deltaX)),
        y: Math.max(0, Math.min(1 - prev.height, prev.y + deltaY))
      }
      return newBox
    })

    setDragOffset({
      x: currentX,
      y: currentY
    })
  }

  function handleMouseUp() {
    setIsDragging(false)
  }

  useEffect(() => {
    if (isDragging) {
      document.addEventListener('mousemove', handleMouseMove)
      document.addEventListener('mouseup', handleMouseUp)
      return () => {
        document.removeEventListener('mousemove', handleMouseMove)
        document.removeEventListener('mouseup', handleMouseUp)
      }
    }
  }, [isDragging, dragOffset, previewWidth, previewHeight])

  async function handleSubmit() {
    setIsSubmitting(true)
    try {
      const response = await fetch(
        `${API_URL}/images/upload/${jobId}/position`,
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            filename: result.filename,
            crop_box: cropBox
          })
        }
      )
      const data = await response.json()
      if (!data.error) {
        onComplete()
      }
    } catch (err) {
      console.error('Positioning failed:', err)
    } finally {
      setIsSubmitting(false)
    }
  }

  return (
    <div className="modal-overlay">
      <div className="modal positioning-modal" onClick={(e) => e.stopPropagation()}>
        <div className="modal-header">
          <h2>Position Image for Frame TV</h2>
        </div>

        <div className="modal-content positioning-content">
          <p>
            This image's aspect ratio ({aspectInfo.aspect.toFixed(2)}:1) isn't close to
            16:9 (1.78:1). Drag the preview to position what you want visible.
          </p>

          <div className="positioning-info">
            <p>
              Original: {aspectInfo.width}√ó{aspectInfo.height}
            </p>
            <p>
              Will be: 3840√ó2160 (4K Frame TV)
            </p>
          </div>

          <div
            ref={containerRef}
            className="crop-preview-container"
            onMouseDown={handleMouseDown}
            style={{
              width: `${previewWidth}px`,
              height: `${previewHeight}px`,
              position: 'relative',
              margin: '20px auto',
              cursor: isDragging ? 'grabbing' : 'grab',
              borderRadius: '4px',
              overflow: 'hidden',
              backgroundColor: 'var(--bg-secondary)',
              border: '2px solid var(--border-color)'
            }}
          >
            <img
              src={result.thumbnail}
              alt="Preview"
              style={{
                width: '100%',
                height: '100%',
                objectFit: 'cover',
                userSelect: 'none',
              }}
            />

            <div
              style={{
                position: 'absolute',
                left: `${cropBox.x * 100}%`,
                top: `${cropBox.y * 100}%`,
                width: `${cropBox.width * 100}%`,
                height: `${cropBox.height * 100}%`,
                border: '2px solid rgba(255, 215, 0, 0.8)',
                boxSizing: 'border-box',
                pointerEvents: 'none'
              }}
            />
          </div>

          <p style={{ fontSize: '12px', color: 'var(--text-muted)', textAlign: 'center' }}>
            Drag the preview to adjust which part is visible. The yellow border shows the final crop.
          </p>
        </div>

        <div className="modal-footer">
          <button className="btn-secondary" disabled={isSubmitting}>
            Cancel
          </button>
          <button
            className="btn-primary"
            onClick={handleSubmit}
            disabled={isSubmitting}
          >
            {isSubmitting ? 'Processing...' : 'Confirm'}
          </button>
        </div>
      </div>
    </div>
  )
}

// ===== IMAGE MODAL =====

function ImageModal({ image, tags, onClose, onTagImage, onUntagImage, onCreateTag, onRemoveImage, onDeleteImage, onDownloadImage }) {
  const [tagSearch, setTagSearch] = useState('')
  const [deleteConfirm, setDeleteConfirm] = useState(null)
  
  if (!image) return null
  
  const availableTags = tags.filter(tag => !image.tags.some(t => t.id === tag.id))
  const searchQuery = tagSearch.toLowerCase().trim()
  const filteredTags = searchQuery 
    ? tags.filter(tag => tag.name.toLowerCase().includes(searchQuery))
    : []
  const tagExists = tags.some(tag => tag.name.toLowerCase() === searchQuery)
  const canCreateTag = searchQuery.length > 0 && !tagExists

  async function handleAddTag(tagId) {
    await onTagImage(image.id, tagId)
    setTagSearch('')
  }

  async function handleCreateTag(name) {
    await onCreateTag(name)
  }

  async function confirmDelete(type) {
    if (type === 'remove') {
      await onRemoveImage(image.id)
    } else if (type === 'delete') {
      await onDeleteImage(image.id)
    }
    setDeleteConfirm(null)
    onClose()
  }

  const dateAdded = new Date(image.date_added).toLocaleDateString()

  return (
    <>
      <div className="modal-overlay" onClick={onClose}>
        <div className="image-modal" onClick={(e) => e.stopPropagation()}>
          <button className="modal-close" onClick={onClose}>‚úï</button>
          
          <div className="modal-image-preview">
            <img src={`${API_URL}/images/${image.id}/preview`} alt={image.name} />
          </div>

          <div className="modal-image-info">
              <div className="modal-properties">
                <div className="property">
                  <span className="property-label">Filename</span>
                  <span className="property-value">{image.name}</span>
                </div>
                
                <div className="property">
                  <span className="property-label">Folder</span>
                  <span className="property-value">{image.folder_path}</span>
                </div>
                
                <div className="property">
                  <span className="property-label">Date Added</span>
                  <span className="property-value">{dateAdded}</span>
                </div>
              </div>

              <div className="modal-tags-section">
                <div className="modal-tag-search">
                  <input
                    type="text"
                    placeholder="Search or create tags..."
                    value={tagSearch}
                    onChange={(e) => setTagSearch(e.target.value)}
                    className="modal-tag-input"
                  />
                  
                  {tagSearch && (
                    <div className="modal-tag-dropdown">
                      {filteredTags.length > 0 && (
                        <div>
                          {filteredTags.map(tag => (
                            <button
                              key={tag.id}
                              className="modal-tag-option"
                              onClick={() => handleAddTag(tag.id)}
                            >
                              + {tag.name}
                            </button>
                          ))}
                        </div>
                      )}
                      
                      {canCreateTag && (
                        <button
                          className="modal-tag-create"
                          onClick={() => handleCreateTag(tagSearch)}
                        >
                          + Create "{tagSearch}"
                        </button>
                      )}
                    </div>
                  )}
                </div>

                <div className="modal-current-tags">
                  {image.tags.length === 0 ? (
                    <p className="no-tags">No tags yet</p>
                  ) : (
                    <div className="tags-list">
                      {image.tags.map(tag => (
                        <span key={tag.id} className="tag-badge-modal">
                          {tag.name}
                          <button
                            className="tag-remove"
                            onClick={() => onUntagImage(image.id, tag.id)}
                          >
                            ‚úï
                          </button>
                        </span>
                      ))}
                    </div>
                  )}
              </div>
            </div>

            <div className="modal-delete-actions">
              <button 
                className="btn-primary"
                onClick={() => onDownloadImage(image.id)}
              >
                Download
              </button>
              <button 
                className="btn-delete-secondary"
                onClick={() => setDeleteConfirm('remove')}
              >
                Remove from FrameFolio
              </button>
              <button 
                className="btn-delete-danger"
                onClick={() => setDeleteConfirm('delete')}
              >
                Delete
              </button>
            </div>
          </div>
        </div>
      </div>

      {deleteConfirm && (
        <div className="modal-overlay" onClick={() => setDeleteConfirm(null)}>
          <div className="modal-confirm" onClick={(e) => e.stopPropagation()}>
            <h3>Confirm {deleteConfirm === 'remove' ? 'Removal' : 'Deletion'}</h3>
            {deleteConfirm === 'remove' ? (
              <p>Remove <strong>{image.name}</strong> from FrameFolio? The file will be kept.</p>
            ) : (
              <p>Delete <strong>{image.name}</strong> completely? This cannot be undone.</p>
            )}
            <div className="modal-confirm-buttons">
              <button className="btn-secondary" onClick={() => setDeleteConfirm(null)}>
                Cancel
              </button>
              <button 
                className={deleteConfirm === 'remove' ? 'btn-secondary' : 'btn-danger'}
                onClick={() => confirmDelete(deleteConfirm)}
              >
                {deleteConfirm === 'remove' ? 'Remove' : 'Delete'}
              </button>
            </div>
          </div>
        </div>
      )}
    </>
  )
}

// ===== MAIN APP =====

function App() {
  const [images, setImages] = useState([])
  const [tags, setTags] = useState([])
  const [folders, setFolders] = useState([])
  const [selectedImage, setSelectedImage] = useState(null)
  const [theme, setTheme] = useState(() => localStorage.getItem('theme') || 'dark')
  
  const [activeSection, setActiveSection] = useState('images')
  const [selectedImages, setSelectedImages] = useState(new Set())
  const [searchQuery, setSearchQuery] = useState('')
  const [batchTagSearch, setBatchTagSearch] = useState('')
  const [viewMode, setViewMode] = useState('medium')
  
  const [showFolderModal, setShowFolderModal] = useState(false)
  const [currentPath, setCurrentPath] = useState('/')
  const [browsingFolders, setBrowsingFolders] = useState([])
  const [parentPath, setParentPath] = useState(null)
  const [folderLoading, setFolderLoading] = useState(false)
  
  const [showTagModal, setShowTagModal] = useState(false)
  const [tagInput, setTagInput] = useState('')
  const [tagPreview, setTagPreview] = useState(null)
  
  const [isScanning, setIsScanning] = useState(false)
  const [selectedTags, setSelectedTags] = useState(new Set())
  const [sortBy, setSortBy] = useState('filename-asc')
  
  const [showUploadModal, setShowUploadModal] = useState(false)
  const [uploadFolderId, setUploadFolderId] = useState(null)

  // Upload state
  const [uploadState, setUploadState] = useState({
    jobId: null,
    uploadingFile: null,
    processing: false
  })

  useEffect(() => {
    loadImages()
    loadTags()
    loadFolders()
  }, [])

  useEffect(() => {
    localStorage.setItem('theme', theme)
    
    let themeToApply = theme
    if (theme === 'auto') {
      const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches
      themeToApply = prefersDark ? 'dark' : 'light'
    }
    
    document.documentElement.setAttribute('data-theme', themeToApply)
    
    if (theme === 'auto') {
      const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)')
      const handleChange = (e) => {
        const newTheme = e.matches ? 'dark' : 'light'
        document.documentElement.setAttribute('data-theme', newTheme)
      }
      
      mediaQuery.addEventListener('change', handleChange)
      return () => mediaQuery.removeEventListener('change', handleChange)
    }
  }, [theme])

  useEffect(() => {
    if (showFolderModal) {
      browseFolders(currentPath)
    }
  }, [showFolderModal])

  async function loadImages() {
    try {
      const response = await fetch(`${API_URL}/images`)
      const data = await response.json()
      setImages(data.images || [])
    } catch (err) {
      console.error(err)
    }
  }

  async function loadTags() {
    try {
      const response = await fetch(`${API_URL}/tags`)
      const data = await response.json()
      setTags(data.tags || [])
    } catch (err) {
      console.error(err)
    }
  }

  async function loadFolders() {
    try {
      const response = await fetch(`${API_URL}/folders`)
      const data = await response.json()
      setFolders(data.folders || [])
    } catch (err) {
      console.error(err)
    }
  }

  async function rescanLibrary() {
    setIsScanning(true)
    try {
      const response = await fetch(`${API_URL}/rescan`, { method: "POST" })
      const data = await response.json()
      if (!data.error) {
        await loadImages()
      }
    } catch (err) {
      console.error("Rescan failed:", err)
    } finally {
      setIsScanning(false)
    }
  }

  async function browseFolders(path) {
    setFolderLoading(true)
    try {
      const response = await fetch(`${API_URL}/folders/browse?path=${encodeURIComponent(path)}`)
      const data = await response.json()
      if (!data.error) {
        setCurrentPath(data.current_path)
        setBrowsingFolders(data.folders || [])
        setParentPath(data.parent_path)
      }
    } catch (err) {
      console.error(err)
    }
    setFolderLoading(false)
  }

  async function selectFolder(path) {
    try {
      const response = await fetch(
        `${API_URL}/folders/add?path=${encodeURIComponent(path)}`,
        { method: 'POST' }
      )
      const data = await response.json()
      if (!data.error) {
        await loadFolders()
        setShowFolderModal(false)
        await loadImages()
      }
    } catch (err) {
      console.error(err)
    }
  }

  async function removeFolder(folderId) {
    if (!window.confirm('Remove folder and all associated images?')) return
    try {
      const response = await fetch(`${API_URL}/folders/${folderId}`, { method: 'DELETE' })
      const data = await response.json()
      if (!data.error) {
        await loadFolders()
        await loadImages()
      }
    } catch (err) {
      console.error(err)
    }
  }

  async function createTag(name) {
    try {
      const response = await fetch(
        `${API_URL}/tags?name=${encodeURIComponent(name.trim())}`,
        { method: 'POST' }
      )
      const data = await response.json()
      if (!data.error) {
        await loadTags()
        return true
      }
    } catch (err) {
      console.error('Error:', err.message)
    }
    return false
  }

  async function handleCreateTags() {
    if (!tagInput.trim()) return
    const newTagNames = tagInput.split(',').map(t => t.trim()).filter(t => t)
    if (newTagNames.length === 0) return
    setTagPreview(newTagNames)
  }

  async function confirmCreateTags() {
    if (!tagPreview) return
    try {
      for (const name of tagPreview) {
        await fetch(`${API_URL}/tags?name=${encodeURIComponent(name)}`, { method: 'POST' })
      }
      await loadTags()
      setTagInput('')
      setTagPreview(null)
      setShowTagModal(false)
    } catch (err) {
      console.error('Error:', err.message)
    }
  }

  async function deleteTag(tagId) {
    if (!window.confirm('Delete this tag?')) return
    try {
      await fetch(`${API_URL}/tags/${tagId}`, { method: 'DELETE' })
      await loadTags()
      await loadImages()
    } catch (err) {
      console.error('Error:', err.message)
    }
  }

  function toggleSelectTag(tagId) {
    const newSelected = new Set(selectedTags)
    if (newSelected.has(tagId)) {
      newSelected.delete(tagId)
    } else {
      newSelected.add(tagId)
    }
    setSelectedTags(newSelected)
  }

  async function deleteSelectedTags() {
    if (!window.confirm(`Delete ${selectedTags.size} tag(s)?`)) return
    try {
      for (const tagId of selectedTags) {
        await fetch(`${API_URL}/tags/${tagId}`, { method: 'DELETE' })
      }
      await loadTags()
      await loadImages()
      setSelectedTags(new Set())
    } catch (err) {
      console.error('Error:', err.message)
    }
  }

  async function handleUpload(e) {
    if (!uploadFolderId) return
    const files = e.target.files
    if (files.length === 0) return

    try {
      const formData = new FormData()
      for (let i = 0; i < files.length; i++) {
        formData.append('files', files[i])
      }

      const startResponse = await fetch(
        `${API_URL}/images/upload/start?folder_id=${uploadFolderId}`,
        { method: 'POST', body: formData }
      )
      const startData = await startResponse.json()

      if (startData.error) {
        alert('Upload failed: ' + startData.error)
        return
      }

      setUploadState({
        jobId: startData.job_id,
        uploadingFile: null,
        processing: true
      })

      pollUploadStatus(startData.job_id)
      e.target.value = ''
    } catch (err) {
      console.error('Upload error:', err.message)
      alert('Upload failed: ' + err.message)
    }
  }

  async function pollUploadStatus(jobId) {
    const pollInterval = setInterval(async () => {
      try {
        const response = await fetch(`${API_URL}/images/upload/${jobId}/status`)
        const status = await response.json()

        const needsAction = status.results.find(
          r => r.status === 'duplicate_detected' || r.status === 'needs_positioning'
        )

        if (needsAction) {
          clearInterval(pollInterval)
          setUploadState(prev => ({
            ...prev,
            uploadingFile: needsAction
          }))
          return
        }

        if (status.status === 'complete') {
          clearInterval(pollInterval)
          await loadImages()
          setShowUploadModal(false)
          setUploadFolderId(null)
          setUploadState({
            jobId: null,
            uploadingFile: null,
            processing: false
          })
          const successful = status.results.filter(r => r.status === 'success').length
          alert(`Upload complete! ${successful}/${status.total_files} images uploaded.`)
        }
      } catch (err) {
        console.error('Poll error:', err)
        clearInterval(pollInterval)
      }
    }, 300)
  }

  function handleUploadModalClose() {
    if (uploadState.processing) {
      if (window.confirm('Upload in progress. Cancel?')) {
        setShowUploadModal(false)
        setUploadFolderId(null)
        setUploadState({ jobId: null, uploadingFile: null, processing: false })
      }
    } else {
      setShowUploadModal(false)
      setUploadFolderId(null)
    }
  }

  async function downloadSingleImage(imageId) {
    try {
      const response = await fetch(`${API_URL}/images/${imageId}/download`)
      const blob = await response.blob()
      const url = window.URL.createObjectURL(blob)
      const a = document.createElement('a')
      a.href = url
      a.download = images.find(img => img.id === imageId)?.name || 'image'
      document.body.appendChild(a)
      a.click()
      window.URL.revokeObjectURL(url)
      document.body.removeChild(a)
    } catch (err) {
      console.error('Error:', err.message)
    }
  }

  async function downloadSelectedImages() {
    if (selectedImages.size === 0) return
    try {
      const response = await fetch(`${API_URL}/images/download-zip`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ image_ids: Array.from(selectedImages) })
      })
      const blob = await response.blob()
      const url = window.URL.createObjectURL(blob)
      const a = document.createElement('a')
      a.href = url
      a.download = 'images.zip'
      document.body.appendChild(a)
      a.click()
      window.URL.revokeObjectURL(url)
      document.body.removeChild(a)
    } catch (err) {
      console.error('Error:', err.message)
    }
  }

  function toggleSelectImage(imageId) {
    const newSelected = new Set(selectedImages)
    if (newSelected.has(imageId)) {
      newSelected.delete(imageId)
    } else {
      newSelected.add(imageId)
    }
    setSelectedImages(newSelected)
  }

  function selectAllImages() {
    setSelectedImages(new Set(sortedImages.map(img => img.id)))
  }

  function clearSelection() {
    setSelectedImages(new Set())
    setSearchQuery('')
  }

  async function addTagToImage(imageId, tagId) {
    try {
      const response = await fetch(
        `${API_URL}/images/${imageId}/tag?tag_id=${tagId}`,
        { method: 'POST' }
      )
      const data = await response.json()
      if (!data.error) {
        await loadImages()
        if (selectedImage?.id === imageId) {
          const updated = await fetch(`${API_URL}/images/${imageId}`).then(r => r.json())
          setSelectedImage(updated)
        }
      }
    } catch (err) {
      console.error('Error:', err.message)
    }
  }

  async function removeTagFromImage(imageId, tagId) {
    try {
      await fetch(
        `${API_URL}/images/${imageId}/tag?tag_id=${tagId}`,
        { method: 'DELETE' }
      )
      await loadImages()
      if (selectedImage?.id === imageId) {
        const updated = await fetch(`${API_URL}/images/${imageId}`).then(r => r.json())
        setSelectedImage(updated)
      }
    } catch (err) {
      console.error('Error:', err.message)
    }
  }

  async function addTagToSelected(tagId) {
    try {
      for (const imageId of selectedImages) {
        await fetch(
          `${API_URL}/images/${imageId}/tag?tag_id=${tagId}`,
          { method: 'POST' }
        )
      }
      await loadImages()
      setBatchTagSearch('')
    } catch (err) {
      console.error('Error:', err.message)
    }
  }

  async function removeTagFromSelected(tagId) {
    try {
      for (const imageId of selectedImages) {
        await fetch(
          `${API_URL}/images/${imageId}/tag?tag_id=${tagId}`,
          { method: 'DELETE' }
        )
      }
      await loadImages()
    } catch (err) {
      console.error('Error:', err.message)
    }
  }

  async function removeImageFromDb(imageId) {
    try {
      const response = await fetch(`${API_URL}/images/${imageId}/remove`, { method: 'DELETE' })
      if (response.ok) {
        await loadImages()
      }
    } catch (err) {
      console.error('Error:', err.message)
    }
  }

  async function deleteImageCompletely(imageId) {
    try {
      const response = await fetch(`${API_URL}/images/${imageId}/delete`, { method: 'DELETE' })
      if (response.ok) {
        await loadImages()
      }
    } catch (err) {
      console.error('Error:', err.message)
    }
  }

  async function removeSelectedFromDb() {
    if (!window.confirm(`Remove ${selectedImages.size} image(s) from FrameFolio? Files will be kept.`)) return
    try {
      for (const imageId of selectedImages) {
        await fetch(`${API_URL}/images/${imageId}/remove`, { method: 'DELETE' })
      }
      await loadImages()
      setSelectedImages(new Set())
    } catch (err) {
      console.error('Error:', err.message)
    }
  }

  async function deleteSelectedCompletely() {
    if (!window.confirm(`Delete ${selectedImages.size} image(s) completely? This cannot be undone.`)) return
    try {
      for (const imageId of selectedImages) {
        await fetch(`${API_URL}/images/${imageId}/delete`, { method: 'DELETE' })
      }
      await loadImages()
      setSelectedImages(new Set())
    } catch (err) {
      console.error('Error:', err.message)
    }
  }

  const filteredImages = images.filter(img => {
    if (!searchQuery.trim()) return true
    const query = searchQuery.toLowerCase()
    const matchesFilename = img.name.toLowerCase().includes(query)
    const matchesTags = img.tags.some(tag => tag.name.toLowerCase().includes(query))
    return matchesFilename || matchesTags
  })

  const sortedImages = [...filteredImages].sort((a, b) => {
    switch(sortBy) {
      case 'filename-asc':
        return a.name.localeCompare(b.name)
      case 'filename-desc':
        return b.name.localeCompare(a.name)
      case 'date-newest':
        return new Date(b.date_added) - new Date(a.date_added)
      case 'date-oldest':
        return new Date(a.date_added) - new Date(b.date_added)
      case 'size-largest':
        return b.size - a.size
      case 'size-smallest':
        return a.size - b.size
      default:
        return 0
    }
  })

  function getCommonTags() {
    if (selectedImages.size === 0) return []
    
    const selectedImageList = Array.from(selectedImages).map(id => 
      images.find(img => img.id === id)
    ).filter(img => img)
    
    if (selectedImageList.length === 0) return []
    
    const firstImageTags = new Set(selectedImageList[0].tags.map(t => t.id))
    
    const commonTagIds = Array.from(firstImageTags).filter(tagId => 
      selectedImageList.every(img => img.tags.some(t => t.id === tagId))
    )
    
    return tags.filter(tag => commonTagIds.includes(tag.id))
  }

  const batchSearchQuery = batchTagSearch.toLowerCase().trim()
  const batchFilteredTags = batchSearchQuery 
    ? tags.filter(tag => tag.name.toLowerCase().includes(batchSearchQuery))
    : []
  const batchTagExists = tags.some(tag => tag.name.toLowerCase() === batchSearchQuery)
  const batchCanCreateTag = batchSearchQuery.length > 0 && !batchTagExists

  const commonTags = getCommonTags()

  return (
    <div className="app" data-theme={theme}>
      <aside className="sidebar">
        <div className="sidebar-header">
          <img src={logoImg} alt="FrameFolio" style={{ height: '40px', width: 'auto' }} />
        </div>
        
        <nav className="sidebar-nav">
          <button
            className={`nav-item ${activeSection === 'images' ? 'active' : ''}`}
            onClick={() => setActiveSection('images')}
          >
            üñºÔ∏è Images
          </button>
          <button
            className={`nav-item ${activeSection === 'library' ? 'active' : ''}`}
            onClick={() => setActiveSection('library')}
          >
            üìÅ Library
          </button>
          <button
            className={`nav-item ${activeSection === 'tags' ? 'active' : ''}`}
            onClick={() => setActiveSection('tags')}
          >
            üè∑Ô∏è Tags
          </button>
          <button
            className={`nav-item ${activeSection === 'appearance' ? 'active' : ''}`}
            onClick={() => setActiveSection('appearance')}
          >
            ‚öôÔ∏è Appearance
          </button>
        </nav>
        
        <div className="sidebar-footer">
          <img src={theme === 'light' ? iconBlack : iconWhite} alt="FrameFolio Icon" />
        </div>
      </aside>

      <main className="main-content">
        {activeSection === 'images' && (
          <section className="content-section">
            <div className="header-bar">
              <div className="stats-bar">
                <div className="stat-item">
                  <span className="stat-label">Total Images</span>
                  <span className="stat-value">{images.length}</span>
                </div>
              </div>
              
              <div className="header-actions">
                {folders.length > 0 && (
                  <button className="btn-primary" onClick={() => setShowUploadModal(true)}>
                    ‚Üë Upload
                  </button>
                )}
                
                {selectedImages.size > 0 && (
                  <button className="btn-download" onClick={downloadSelectedImages}>
                    ‚Üì Download Selected Images ({selectedImages.size})
                  </button>
                )}
              </div>
            </div>

            <div className="images-controls">
              <input
                type="text"
                placeholder="Search by filename or tag..."
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
                className="search-input"
              />
              
              {selectedImages.size > 0 && (
                <div className="selection-info">
                  <span>{selectedImages.size} selected</span>
                  <button className="btn-secondary" onClick={clearSelection}>
                    Clear
                  </button>
                </div>
              )}
              
              {sortedImages.length > 0 && (
                <button className="btn-secondary" onClick={selectAllImages}>
                  Select All
                </button>
              )}
            </div>

            <div className="controls-bar">
              <div className="sort-selector">
                <select 
                  value={sortBy} 
                  onChange={(e) => setSortBy(e.target.value)}
                  className="sort-dropdown"
                >
                  <option value="filename-asc">Filename (A-Z)</option>
                  <option value="filename-desc">Filename (Z-A)</option>
                  <option value="date-newest">Date Added (Newest)</option>
                  <option value="date-oldest">Date Added (Oldest)</option>
                  <option value="size-largest">Size (Largest)</option>
                  <option value="size-smallest">Size (Smallest)</option>
                </select>
              </div>

              <div className="view-mode-selector">
                <button
                  className={`view-btn ${viewMode === 'list' ? 'active' : ''}`}
                  onClick={() => setViewMode('list')}
                  title="List view"
                >
                  ‚ò∞
                </button>
                <button
                  className={`view-btn ${viewMode === 'small' ? 'active' : ''}`}
                  onClick={() => setViewMode('small')}
                  title="Small thumbnails"
                >
                  ‚äû‚äû‚äû
                </button>
                <button
                  className={`view-btn ${viewMode === 'medium' ? 'active' : ''}`}
                  onClick={() => setViewMode('medium')}
                  title="Medium thumbnails"
                >
                  ‚äû‚äû
                </button>
                <button
                  className={`view-btn ${viewMode === 'large' ? 'active' : ''}`}
                  onClick={() => setViewMode('large')}
                  title="Large thumbnails"
                >
                  ‚äû
                </button>
              </div>
            </div>

            {selectedImages.size > 0 && (
              <div className="batch-tag-section">
                {commonTags.length > 0 && (
                  <div className="common-tags-bar">
                    <span className="common-tags-label">Applied to all:</span>
                    <div className="common-tags-list">
                      {commonTags.map(tag => (
                        <button
                          key={tag.id}
                          className="common-tag-badge"
                          onClick={() => removeTagFromSelected(tag.id)}
                          title="Click to remove from all selected"
                        >
                          {tag.name} <span className="remove-x">‚úï</span>
                        </button>
                      ))}
                    </div>
                  </div>
                )}

                <div className="batch-delete-bar">
                  <button 
                    className="btn-delete-secondary"
                    onClick={removeSelectedFromDb}
                  >
                    Remove from FrameFolio
                  </button>
                  <button 
                    className="btn-delete-danger"
                    onClick={deleteSelectedCompletely}
                  >
                    Delete
                  </button>
                </div>

                <div className="batch-tag-bar">
                  <input
                    type="text"
                    placeholder="Search tags to apply..."
                    value={batchTagSearch}
                    onChange={(e) => setBatchTagSearch(e.target.value)}
                    className="batch-tag-input"
                  />
                  
                  {batchTagSearch && (
                    <div className="batch-tag-options">
                      {batchFilteredTags.length > 0 && (
                        <div>
                          {batchFilteredTags.map(tag => (
                            <button
                              key={tag.id}
                              className="batch-tag-option"
                              onClick={() => addTagToSelected(tag.id)}
                            >
                              + {tag.name}
                            </button>
                          ))}
                        </div>
                      )}
                      
                      {batchCanCreateTag && (
                        <button
                          className="batch-tag-create"
                          onClick={() => createTag(batchTagSearch)}
                        >
                          + Create "{batchTagSearch}"
                        </button>
                      )}
                    </div>
                  )}
                </div>
              </div>
            )}

            <div className={`images-grid-with-select view-${viewMode}`}>
              {sortedImages.map((img) => (
                <div 
                  key={img.id}
                  className={`image-card-wrapper ${selectedImages.has(img.id) ? 'selected' : ''}`}
                >
                  <input
                    type="checkbox"
                    className="image-checkbox"
                    checked={selectedImages.has(img.id)}
                    onChange={() => toggleSelectImage(img.id)}
                  />
                  <div 
                    className="image-card"
                    onClick={() => setSelectedImage(img)}
                  >
                    <img 
                      src={`${API_URL}/images/${img.id}/thumbnail`} 
                      alt={img.name}
                      className="image-thumbnail"
                    />
                    <p>{img.name}</p>
                    {img.tags.length > 0 && (
                      <div className="image-tags">
                        {img.tags.slice(0, 3).map(t => <span key={t.id}>#{t.name}</span>)}
                        {img.tags.length > 3 && <span>+{img.tags.length - 3}</span>}
                      </div>
                    )}
                  </div>
                </div>
              ))}
            </div>
            {sortedImages.length === 0 && (
              <div className="empty-state">
                {searchQuery ? 'No images match your search.' : 'No images found. Add folders in Library to get started.'}
              </div>
            )}
          </section>
        )}

        {activeSection === 'library' && (
          <section className="content-section">
            <h2>Folder Management</h2>
            <div className="library-controls">
              <button className="btn-primary" onClick={() => setShowFolderModal(true)}>
                + Add Folder
              </button>
              <button 
                className="btn-secondary" 
                onClick={rescanLibrary}
                disabled={isScanning}
              >
                {isScanning ? '‚ü≥ Scanning...' : '‚ü≥ Rescan Library'}
              </button>
            </div>
            
            <div className="folders-list">
              {folders.length === 0 ? (
                <p className="empty-state">No folders configured yet</p>
              ) : (
                folders.map((folder) => (
                  <div key={folder.id} className="folder-item">
                    <div className="folder-path">{folder.path}</div>
                    <button
                      className="btn-danger"
                      onClick={() => removeFolder(folder.id)}
                    >
                      Remove
                    </button>
                  </div>
                ))
              )}
            </div>
          </section>
        )}

        {activeSection === 'tags' && (
          <section className="content-section">
            <h2>Tag Management</h2>
            <button className="btn-primary" onClick={() => setShowTagModal(true)}>
              + Add Tags
            </button>
            
            {selectedTags.size > 0 && (
              <div className="tag-selection-bar">
                <span>{selectedTags.size} selected</span>
                <button className="btn-secondary" onClick={() => setSelectedTags(new Set())}>
                  Clear
                </button>
                <button className="btn-danger" onClick={deleteSelectedTags}>
                  Delete Selected
                </button>
              </div>
            )}
            
            <div className="tags-list">
              {tags.length === 0 ? (
                <p className="empty-state">No tags yet</p>
              ) : (
                tags.map((tag) => (
                  <div key={tag.id} className={`tag-item ${selectedTags.has(tag.id) ? 'selected' : ''}`}>
                    <div className="tag-item-header">
                      <input
                        type="checkbox"
                        className="tag-checkbox"
                        checked={selectedTags.has(tag.id)}
                        onChange={() => toggleSelectTag(tag.id)}
                      />
                      <span>{tag.name}</span>
                    </div>
                    <button
                      className="btn-danger btn-small"
                      onClick={() => deleteTag(tag.id)}
                    >
                      Delete
                    </button>
                  </div>
                ))
              )}
            </div>
          </section>
        )}

        {activeSection === 'appearance' && (
          <section className="content-section">
            <h2>UI Management</h2>
            
            <div className="settings-group">
              <h3>Theme</h3>
              <div className="theme-options">
                <label>
                  <input
                    type="radio"
                    name="theme"
                    value="light"
                    checked={theme === 'light'}
                    onChange={(e) => setTheme(e.target.value)}
                  />
                  ‚òÄÔ∏è Light
                </label>
                <label>
                  <input
                    type="radio"
                    name="theme"
                    value="dark"
                    checked={theme === 'dark'}
                    onChange={(e) => setTheme(e.target.value)}
                  />
                  üåô Dark
                </label>
                <label>
                  <input
                    type="radio"
                    name="theme"
                    value="auto"
                    checked={theme === 'auto'}
                    onChange={(e) => setTheme(e.target.value)}
                  />
                  ‚öôÔ∏è Auto (System)
                </label>
              </div>
            </div>
          </section>
        )}
      </main>

      <ImageModal 
        image={selectedImage}
        tags={tags}
        onClose={() => setSelectedImage(null)}
        onTagImage={addTagToImage}
        onUntagImage={removeTagFromImage}
        onCreateTag={createTag}
        onRemoveImage={removeImageFromDb}
        onDeleteImage={deleteImageCompletely}
        onDownloadImage={downloadSingleImage}
      />

      {showFolderModal && (
        <div className="modal-overlay" onClick={() => setShowFolderModal(false)}>
          <div className="modal" onClick={(e) => e.stopPropagation()}>
            <div className="modal-header">
              <h2>Select Folder</h2>
              <button className="modal-close" onClick={() => setShowFolderModal(false)}>‚úï</button>
            </div>
            
            <div className="modal-content">
              <div className="browser-path">
                <button 
                  className="btn-secondary"
                  onClick={() => parentPath && browseFolders(parentPath)}
                  disabled={!parentPath}
                >
                  ‚Üê Back
                </button>
                <span className="path-text">{currentPath}</span>
              </div>
              
              {folderLoading ? (
                <div className="loading">Loading...</div>
              ) : (
                <div className="folders-browser">
                  {browsingFolders.length === 0 ? (
                    <p className="empty-state">No subdirectories</p>
                  ) : (
                    browsingFolders.map((folder) => (
                      <div key={folder.path} className="browser-item">
                        <span 
                          className="folder-name"
                          onClick={() => browseFolders(folder.path)}
                        >
                          üìÅ {folder.name}
                        </span>
                        <button
                          className="btn-success"
                          onClick={() => selectFolder(folder.path)}
                        >
                          Add
                        </button>
                      </div>
                    ))
                  )}
                </div>
              )}
            </div>
            
            <div className="modal-footer">
              <button className="btn-secondary" onClick={() => setShowFolderModal(false)}>
                Cancel
              </button>
            </div>
          </div>
        </div>
      )}

      {showTagModal && !tagPreview && (
        <div className="modal-overlay" onClick={() => setShowTagModal(false)}>
          <div className="modal" onClick={(e) => e.stopPropagation()}>
            <div className="modal-header">
              <h2>Create Tags</h2>
              <button className="modal-close" onClick={() => setShowTagModal(false)}>‚úï</button>
            </div>
            
            <div className="modal-content">
              <label>Tag names (comma-separated):</label>
              <input
                type="text"
                placeholder="Portrait, Landscape, Monet"
                value={tagInput}
                onChange={(e) => setTagInput(e.target.value)}
                style={{
                  width: '100%',
                  padding: '10px',
                  marginBottom: '10px',
                  borderRadius: '4px',
                  border: '1px solid var(--border-color)',
                  background: 'var(--bg-tertiary)',
                  color: 'var(--text-primary)'
                }}
              />
              <p style={{ fontSize: '12px', color: 'var(--text-muted)' }}>
                üí° Separate multiple tags with commas
              </p>
            </div>
            
            <div className="modal-footer">
              <button className="btn-secondary" onClick={() => { setShowTagModal(false); setTagInput('') }}>
                Cancel
              </button>
              <button className="btn-primary" onClick={handleCreateTags} disabled={!tagInput.trim()}>
                Create
              </button>
            </div>
          </div>
        </div>
      )}

      {tagPreview && (
        <div className="modal-overlay" onClick={() => setTagPreview(null)}>
          <div className="modal" onClick={(e) => e.stopPropagation()}>
            <div className="modal-header">
              <h2>Confirm</h2>
              <button className="modal-close" onClick={() => setTagPreview(null)}>‚úï</button>
            </div>
            
            <div className="modal-content">
              <p>Create {tagPreview.length} tag{tagPreview.length > 1 ? 's' : ''}?</p>
              <div className="tag-preview-list">
                {tagPreview.map((name, i) => (
                  <div key={i} className="tag-preview-item">
                    {name}
                  </div>
                ))}
              </div>
            </div>
            
            <div className="modal-footer">
              <button className="btn-secondary" onClick={() => setTagPreview(null)}>
                Cancel
              </button>
              <button className="btn-primary" onClick={confirmCreateTags}>
                Confirm
              </button>
            </div>
          </div>
        </div>
      )}

      {showUploadModal && (
        <div className="modal-overlay" onClick={handleUploadModalClose}>
          <div className="modal" onClick={(e) => e.stopPropagation()}>
            <div className="modal-header">
              <h2>Upload Images for Frame TV</h2>
              <button className="modal-close" onClick={handleUploadModalClose}>‚úï</button>
            </div>
            
            <div className="modal-content">
              <p>Select folder for upload:</p>
              <div className="folders-select">
                {folders.map(folder => (
                  <button
                    key={folder.id}
                    className={`folder-select-btn ${uploadFolderId === folder.id ? 'selected' : ''}`}
                    onClick={() => setUploadFolderId(folder.id)}
                    disabled={uploadState.processing}
                  >
                    {folder.path}
                  </button>
                ))}
              </div>
            </div>
            
            <div className="modal-footer">
              <button 
                className="btn-secondary" 
                onClick={handleUploadModalClose}
                disabled={uploadState.processing}
              >
                Cancel
              </button>
              {uploadFolderId && (
                <>
                  <input
                    type="file"
                    id="file-input"
                    multiple
                    accept="image/*"
                    onChange={handleUpload}
                    style={{ display: 'none' }}
                    disabled={uploadState.processing}
                  />
                  <button 
                    className="btn-primary"
                    onClick={() => document.getElementById('file-input').click()}
                    disabled={uploadState.processing}
                  >
                    Select Files
                  </button>
                </>
              )}
            </div>
          </div>
        </div>
      )}

      {uploadState.processing && uploadState.jobId && !uploadState.uploadingFile && (
        <UploadProgressModal
          jobId={uploadState.jobId}
          onComplete={() => {
            setUploadState({
              jobId: null,
              uploadingFile: null,
              processing: false
            })
          }}
          onError={(errors) => {
            alert('Upload error: ' + errors[0])
            setUploadState({
              jobId: null,
              uploadingFile: null,
              processing: false
            })
          }}
        />
      )}

      {uploadState.uploadingFile?.status === 'duplicate_detected' && (
        <DuplicateModal
          result={uploadState.uploadingFile}
          jobId={uploadState.jobId}
          onAction={() => {
            setUploadState(prev => ({
              ...prev,
              uploadingFile: null
            }))
            if (uploadState.jobId) {
              pollUploadStatus(uploadState.jobId)
            }
          }}
        />
      )}

      {uploadState.uploadingFile?.status === 'needs_positioning' && (
        <CropPositioningModal
          result={uploadState.uploadingFile}
          jobId={uploadState.jobId}
          onComplete={() => {
            setUploadState(prev => ({
              ...prev,
              uploadingFile: null
            }))
            if (uploadState.jobId) {
              pollUploadStatus(uploadState.jobId)
            }
          }}
        />
      )}
    </div>
  )
}

export default App
